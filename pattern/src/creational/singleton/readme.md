## Singleton 单例模式

定义：
- 保证一个类仅有一个实例，并提供一个全局访问点。

使用场景：
- 想保证任何情况下都只有一个实例

优点：
- 节省内存

缺点：
- 扩展困难

补充：
单例模式的五种写法
1. [饿汉式](java/HungrySingleton.java)
    - 类加载的时候就实例化对象，如果从未使用则会造成资源浪费
    - 是线程安全的
    - 可以实现不被序列化破坏单例
    - 可以实现不被反射破坏单例
    
2. [懒汉式](java/LazySingleton.java)
    - 在调用实例方法时才实例化对象
    - 在实例方法上加上`synchronized`关键字可以实现线程安全，
    否则是线程不安全。加上`synchronized`后每次调用都会同步，会造成不必要的同步开销
    - 可以实现不被序列化破坏单例
    - 不能实现不被反射破坏单例
    
3. [双重检查式](java/LazyDoubleCheckSingleton.java)
    - 在调用实例方法时才实例化对象
    - 是线程安全的，减少了同步造成的不必要开销，
    使用`volatile`保证了有序性，防止多线程情况下因指令重排造成的异常
    - 可以实现不被序列化破坏单例
    - 不能实现不被反射破坏单例

4. [静态内部类式](java/StaticInnerClassSingleton.java)
    - 在调用实例方法时才会加载内部类，从而实例化自身对象
    - 是线程安全的
    - 可以实现不被序列化破坏单例
    - 可以实现不被反射破坏单例
    
5. [枚举单例](java/EnumInstance.java)
    - 类加载的时候就会实例化对象，与饿汉式相似
    - 是线程安全的
    - io包保证了序列化不会破坏单例
    - reflect包保证了不能使用反射创建enum对象
    - 构造器默认是私有的
